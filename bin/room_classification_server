#!/usr/bin/env python3
"""Run inference on received scene graphs."""
import hydra_gnn.mp3d_dataset
import spark_dsg as dsg
import pandas as pd
import numpy as np
import torch_geometric
import gensim.models
import pathlib
import pickle
import torch
import click
import yaml


DataConverter = hydra_gnn.mp3d_dataset.Hydra_mp3d_data
HtreeDataConverter = hydra_gnn.mp3d_dataset.Hydra_mp3d_htree_data

DEFAULT_LAYERS = (dsg.DsgLayers.OBJECTS, dsg.DsgLayers.ROOMS, dsg.DsgLayers.BUILDINGS)


class GnnModel:
    """Class to hold stuff regarding inference."""

    def __init__(self, model_file, word2vec_file, config_file, load_word2vec=True):
        """Load everything."""
        model_path = pathlib.Path(model_file).expanduser().absolute()
        with model_path.open("rb") as fin:
            self.model = pickle.load(fin)

        word2vec_path = pathlib.Path(word2vec_file).expanduser().absolute()
        if load_word2vec:
            word2vec = _load_word2vec(word2vec_path)
        else:
            word2vec = {}

        config_path = pathlib.Path(config_file).expanduser().absolute()
        with config_path.open("r") as fin:
            self.config = yaml.load(fin.read(), Loader=yaml.SafeLoader)

        self.object_labels = [x for _, x in self.config["object_labels"].items()]
        self.object_embeddings = {
            idx: _get_embedding(word2vec, label)
            for idx, label in enumerate(self.object_labels)
        }

        self.building_labels = sorted(self.config["building_labels"])
        self.room_labels = sorted(self.config["room_labels"])

        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model.to(self.device)

    def infer(self, G):
        """Run inference on a given scene graph."""
        preprocess_dsg(G)
        torch_graph, room_idx_map = convert_to_torch_data(
            G, self.object_embeddings, add_edge_attr=True
        )

        with torch.no_grad():
            pred = self.model(torch_graph.to(self.device))
            building_pred = pred[0].argmax(dim=1).cpu()
            room_pred = pred[1].argmax(dim=1).cpu()
            if len(building_pred) == 1:
                building_name = self.building_labels[building_pred[0]]
                print(f"building: {building_name}")
            pred_room_labels = [self.room_labels[x] for x in room_pred]
            pred_room_map = {
                room: pred_room_labels[idx] for room, idx in room_idx_map.items()
            }
            print(f"rooms: {pred_room_map}")
            return pred_room_map


@click.group()
def main():
    """Start an inference server or send an graph to the server."""
    pass


@main.command()
@click.argument("server")
@click.argument("word2vec-file")
@click.argument("config")
@click.option("--recv-url", "-r", default="tcp://127.0.0.1:8001")
@click.option("--send-url", "-s", default="tcp://127.0.0.1:8002")
@click.option("--num-threads", "-t", default=2)
@click.option("--poll-time-ms", default=10)
def run(network, word2vec_file, config, recv_url, send_url, num_threads, poll_time_ms):
    """Start an inference server for a specific model checkpoint."""
    model = GnnModel(network, word2vec_file, config)

    click.secho(f"setting up sender @ {send_url}", fg="green")
    sender = dsg.DsgSender(send_url)

    click.secho(f"setting up receiver @ {recv_url}", fg="green")
    receiver = dsg.DsgReceiver(recv_url)

    while True:
        if not receiver.recv(poll_time_ms):
            continue

        predicted_labels = model.infer(receiver.graph)

        G = dsg.DynamicSceneGraph()
        for room_id, label in predicted_labels.items():
            attrs = dsg.RoomNodeAttributes()
            attrs.name = f"{room_id}: {label}"
            G.add_node(dsg.DsgLayers.ROOMS, room_id.value, attrs)

        sender.send(G)


if __name__ == "__main__":
    main()
